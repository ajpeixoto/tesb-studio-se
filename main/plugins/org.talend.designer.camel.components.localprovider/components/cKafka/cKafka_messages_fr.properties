LONG_NAME=Composant g\u00E9n\u00E9rique pour Kafka
HELP=org.talend.esb.help.cKafka
BROKER_LIST.NAME=Liste des brokers
BROKER_LIST.DESCRIPTION=URL des brokers Kafka \u00E0 utiliser. Le format est host1:port1,host2:port2. La liste peut \u00EAtre un sous-ensemble de brokers ou un VIP pointant vers un sous-ensemble de brokers.\n Cette option est conue sous le nom bootstrap.servers dans la documentation Kafka
CLIENT_ID.NAME=ID client
CLIENT_ID.DESCRIPTION=L'ID client est une cha\u00EEne de caract\u00E8res sp\u00E9cifi\u00E9e par l'utilisateur, envoy\u00E9e dans chaque requ\u00EAte, pour tracer les appels. \nIl doit identifier logiquement l'application effectuant la requ\u00EAte.
TOPIC.NAME=Sujet
TOPIC.DESCRIPTION=Nom du topic
GROUP_ID.NAME=ID du groupe :
GROUP_ID.DESCRIPTION=Cha\u00EEne de caract\u00E8res identifiant de mani\u00E8re unique les processus du groupe de consommateurs auquel ce consommateur appartient. \nEn configurant le m\u00EAme ID de groupe, plusieurs processus indiquent qu'ils font tous partie du m\u00EAme groupe de consommateurs.
PARTITIONER.NAME=Partitionnement
PARTITIONER.DESCRIPTION=Classe de partition pour partitionner les messages parmi les sous-topics. \nLe partitionneur par d\u00E9faut se base sur le hachage de la cl\u00E9.
URI_OPTIONS.NAME=Propri\u00E9t\u00E9s Kafka
URI_OPTIONS.ITEM.NAME=Nom
URI_OPTIONS.ITEM.VALUE=Valeur
COMPRESSION_CODEC.NAME=Codec de compression
COMPRESSION_CODEC.DESCRIPTION=Ce param\u00E8tre vous permet de sp\u00E9cifier le codec de compression pour toutes les donn\u00E9es g\u00E9n\u00E9r\u00E9es par ce producteur. \nLes valeurs valides sont\u00A0: aucune, gzip, snappy, lz4 et zstd.
COMPRESSION_CODEC.ITEM.NONE=AUCUNE
COMPRESSION_CODEC.ITEM.GZIP=GZIP
COMPRESSION_CODEC.ITEM.SNAPPY=Snappy
COMPRESSION_CODEC.ITEM.LZ4=LZ4
REQUEST_REQUIRED_ACKS.NAME=Demander un accus\u00E9 de r\u00E9ception
REQUEST_REQUIRED_ACKS.DESCRIPTION=Nombre d'accus\u00E9s de r\u00E9ception re\u00E7us par le leader, requis par le producteur, avant de consid\u00E9rer une requ\u00EAte comme compl\u00E8te. \nCela permet de contr\u00F4ler la durabilit\u00E9 des enregistrements envoy\u00E9s. \nLes param\u00E8tres suivants sont autoris\u00E9s\u00A0: acks=0 Si configur\u00E9 \u00E0 z\u00E9ro, le producteur n'attend pas d'accus\u00E9 de r\u00E9ception de la part du serveur. \nL'enregistrement est imm\u00E9diatement ajout\u00E9 \u00E0 la m\u00E9moire tampon du socket et consid\u00E9r\u00E9 comme envoy\u00E9. \nIl n'est pas possible de garantir que le serveur a re\u00E7u l'enregistrement, dans ce cas. La configuration des nouvelles tentatives ne sera pas prise en compte (comme le client n'est g\u00E9n\u00E9ralement pas au courant des \u00E9checs).\n L'offset retourn\u00E9 pour chaque enregistrement est toujours configur\u00E9 comme -1. \nacks=1 Cela signifie que le leader \u00E9crit l'enregistrement dans son log local mais r\u00E9pond sans attendre un accus\u00E9 de r\u00E9ception complet de tous les followers. \nDans ce cas, le leader \u00E9choue imm\u00E9diatement apr\u00E8s avoir accus\u00E9 r\u00E9ception de l'enregistrement, mais avant que les followers ne l'aient r\u00E9pliqu\u00E9. L'enregistrement est alors perdu. \nacks=all Cela signifie que le leader attend l'ensemble complet de r\u00E9pliques synchronis\u00E9es pour accuser r\u00E9ception de l'enregistrement. \nCela permet de garantir que l'enregistrement n'est pas perdu, tant qu'une r\u00E9plique synchronis\u00E9e est active. \nC'est la plus forte garantie disponible. Elle est l'\u00E9quivalent du param\u00E8tre acks=-1. \nActiver l'idempotence n\u00E9cessite de configurer cette valeur \u00E0 'tous'. Si des configurations sont en conflit et que l'idempotence n'est pas explicitement activ\u00E9e, l'idempotence est d\u00E9sactiv\u00E9e.
REQUEST_REQUIRED_ACKS.ITEM.MINUS_ONE=-1
REQUEST_REQUIRED_ACKS.ITEM.ZERO=0
REQUEST_REQUIRED_ACKS.ITEM.ONE=1
REQUEST_REQUIRED_ACKS.ITEM.ALL=TOUT
RETRY_BACKOFF_MS.NAME=R\u00E9essayer le backoff (ms)
RETRY_BACKOFF_MS.DESCRIPTION=Avant chaque nouvelle tentative, le producteur actualise les m\u00E9tadonn\u00E9es des topics pertinents, afin de voir si un nouveau leader a \u00E9t\u00E9 \u00E9lu. \nComme l'\u00E9lection d'un leader prend du temps, cette propri\u00E9t\u00E9 sp\u00E9cifie l'intervalle de temps durant lequel le producteur attend, avant d'actualiser les m\u00E9tadonn\u00E9es.
SEND_BUFFER_BYTES.NAME=Envoyer de la m\u00E9moire tampon (octets)
SEND_BUFFER_BYTES.DESCRIPTION=Taille de la m\u00E9moire tampon pour l'\u00E9criture dans le socket.
REQUEST_TIMEOUT_MS.NAME=Requ\u00EAte suspendue (en ms)
REQUEST_TIMEOUT_MS.DESCRIPTION=Intervalle de temps durant lequel le broker attend en essayant de se conformer au pr\u00E9requis request.required.acks, avant de retourner une erreur au client.
SERIALIZER_CLASS.NAME=Classe du s\u00E9rialiseur
SERIALIZER_CLASS.DESCRIPTION=Classe de s\u00E9rialiseur pour les messages.
KEY_SERIALIZER_CLASS.NAME=Classe du s\u00E9rialiseur de cl\u00E9
KEY_SERIALIZER_CLASS.DESCRIPTION=Classe de s\u00E9rialiseur pour les cl\u00E9s (par d\u00E9faut, la valeur est la m\u00EAme que celles des messages si aucune valeur n'est sp\u00E9cifi\u00E9e).
AUTO_COMMIT_ENABLE.NAME=Autoriser le commit auto
AUTO_COMMIT_ENABLE.DESCRIPTION=Lorsque cette propri\u00E9t\u00E9 est configur\u00E9e \u00E0 Vrai, un commit p\u00E9riodique de l'offset des messages d\u00E9j\u00E0 r\u00E9cup\u00E9r\u00E9s par le consommateur est effectu\u00E9 dans ZooKeeper. \nL'offset commit\u00E9 sera utilis\u00E9 lors de l'\u00E9chec du processus comme position \u00E0 laquelle doit commencer le nouveau consommateur.
AUTO_COMMIT_INTERVAL_MS.NAME=Intervalle d'auto commit (en ms)
AUTO_COMMIT_INTERVAL_MS.DESCRIPTION=Fr\u00E9quence en millisecondes \u00E0 laquelle les offsets du consommateur sont commit\u00E9s dans ZooKeeper.
FETCH_MIN_BYTES.NAME=Requ\u00EAte de r\u00E9cup\u00E9ration min (octets)
FETCH_MIN_BYTES.DESCRIPTION=Nombre minimal de donn\u00E9es que le serveur doit retourner pour une requ\u00EAte de r\u00E9cup\u00E9ration (fetch). \nS'il n'y a pas assez de donn\u00E9es disponibles, la requ\u00EAte attendra que la quantit\u00E9 de donn\u00E9es n\u00E9cessaire soit disponible avant de r\u00E9pondre \u00E0 la requ\u00EAte.
FETCH_WAIT_MAX_MS.NAME=Temps attente max pour une requ\u00EAte de r\u00E9cup\u00E9ration (en ms)
FETCH_WAIT_MAX_MS.DESCRIPTION=Dur\u00E9e maximale pendant laquelle le serveur sera bloqu\u00E9 avant de r\u00E9pondre \u00E0 la requ\u00EAte de r\u00E9cup\u00E9ration s'il n'y a pas assez de donn\u00E9es imm\u00E9diatement disponibles pour correspondre \u00E0 la valeur de fetch.min.bytes.
AUTO_OFFSET_RESET.NAME=R\u00E9initialisation de l'offset automatique
AUTO_OFFSET_RESET.DESCRIPTION=Action \u00E0 effectuer s'il n'y a pas d'offset initial dans ZooKeeper ou si un offset n'est pas dans l'intervalle\u00A0: \nplus ancien\u00A0: r\u00E9initialiser automatiquement l'offset au plus ancien. \nplus r\u00E9cent\u00A0: r\u00E9initialiser automatiquement l'offset au plus r\u00E9cent. \n\u00E9chec\u00A0: retourner une exception au consommateur.
AUTO_OFFSET_RESET.ITEM.LATEST=PLUS R\u00C9CENT
AUTO_OFFSET_RESET.ITEM.EARLIEST=PLUS ANCIEN
AUTO_OFFSET_RESET.ITEM.NONE=AUCUNE
SSL.NAME=SSL
SSL_KEY_PASSWORD.NAME=Mot de passe la cl\u00E9 priv\u00E9e SSL
SSL_KEY_PASSWORD.DESCRIPTION=Mot de passe de la cl\u00E9 priv\u00E9e dans le fichier Keystore ou cl\u00E9 PEM sp\u00E9cifi\u00E9e dans sslKeystoreKey. \nRequis pour les clients uniquement si une authentification bidirectionnelle est configur\u00E9e.
SSL_KEYSTORE_LOCATION.NAME=Emplacement du Keystore SSL
SSL_KEYSTORE_LOCATION.DESCRIPTION=Emplacement du fichier Keystore. Cette propri\u00E9t\u00E9 est facultative pour le client et peut \u00EAtre utilis\u00E9e pour l'authentification bidirectionnelle du client.
SSL_KEYSTORE_PASSWORD.NAME=Mot de passe du Keystore SSL
SSL_KEYSTORE_PASSWORD.DESCRIPTION=Mot de passe pour le fichier Keystore. Facultatif pour le client et n\u00E9cessaire uniquement si le param\u00E8tre sslKeystoreLocation est configur\u00E9. \nLe mot de passe pour le Keystore n'est pas support\u00E9 pour le format PEM.
SSL_TRUSTSTORE_LOCATION.NAME=Emplacement du Truststore SSL
SSL_TRUSTSTORE_LOCATION.DESCRIPTION=Emplacement du fichier Truststore.
SSL_TRUSTSTORE_PASSWORD.NAME=Mot de passe du Truststore SSL
SSL_TRUSTSTORE_PASSWORD.DESCRIPTION=Mot de passe pour acc\u00E9der au fichier Truststore. Si aucun mot de passe n'est sp\u00E9cifi\u00E9, le fichier Truststore configur\u00E9 est utilis\u00E9, mais la v\u00E9rification d'int\u00E9grit\u00E9 est d\u00E9sactiv\u00E9e. \nLe mot de passe pour le Truststore n'est pas support\u00E9 pour le format PEM.
SSL_CIPHER_SUITS.NAME=Listes cryptographiques SSL
SSL_CIPHER_SUITS.DESCRIPTION=Liste de suites cryptographiques. Ceci est une combinaison nomm\u00E9e d'algorithmes d'authentification, de chiffrement, \nd'authentification de message (CAM) et d'\u00E9change de cl\u00E9s, utilis\u00E9s pour n\u00E9gocier les param\u00E8tres de s\u00E9curit\u00E9 pour une connexion au r\u00E9seau utilisant un protocole TLS ou SSL. \nPar d\u00E9faut, toutes les suites cryptographiques sont support\u00E9es.
SSL_ENDPOINT_ALGORITHM.NAME=Algorithme d'identification de l'endpoint SSL
SSL_ENDPOINT_ALGORITHM.DESCRIPTION=Algorithme d'identification de l'endpoint pour valider le nom d'h\u00F4te du serveur \u00E0 l'aide du certificat du serveur. \nUtilisez Aucun ou Faux pour d\u00E9sactiver la v\u00E9rification du nom d'h\u00F4te du serveur.
SASL.NAME=SASL
SASL_KERBEROS_SERVICE_NAME.NAME=Nom du service Kerberos
SASL_KERBEROS_SERVICE_NAME.DESCRIPTION=Nom du Principal Kerberos avec lequel Kafka s'ex\u00E9cute. Il peut \u00EAtre d\u00E9fini soit dans la configuration JAAS de Kafka, soit dans la configuration de Kafka.
SECURITY_PROTOCOL.NAME=Protocole de s\u00E9curit\u00E9
SECURITY_PROTOCOL.DESCRIPTION=Protocole utilis\u00E9 pour communiquer avec les brokers. Les protocoles SASL_PLAINTEXT, PLAINTEXT, SASL_SSL et SSL sont support\u00E9s.
SECURITY_PROTOCOL.ITEM.PLAINTEXT=Plaintext
SECURITY_PROTOCOL.ITEM.SSL=SSL
SECURITY_PROTOCOL.ITEM.SASL_PLAINTEXT=SASL over Plaintext
SECURITY_PROTOCOL.ITEM.SASL_SSL=SASL over SSL
HEARTBEAT_INTERVAL_MS.NAME=Fr\u00E9quence des signaux de pr\u00E9sence (ms)
HEARTBEAT_INTERVAL_MS.DESCRIPTION=Temps d'attente attendu entre deux pulsations envoy\u00E9es au coordinateur des consommateurs lors de l'utilisation des fonctionnalit\u00E9s de gestion de groupes de Kafka. \nLes pulsations sont utilis\u00E9es pour assurer que la session du consommateur reste active, ainsi que pour faciliter la redistribution lorsque de nouveaux consommateurs rejoignent ou quittent le groupe. \nLa valeur doit \u00EAtre param\u00E9tr\u00E9e pour \u00EAtre inf\u00E9rieure \u00E0 la valeur de session.timeout.ms, mais ne doit g\u00E9n\u00E9ralement pas d\u00E9passer un tiers de cette valeur. \nElle peut \u00EAtre configur\u00E9e \u00E0 une valeur encore plus basse, afin de contr\u00F4ler le temps attendu pour les redistributions normales.
MAX_PARTITION_FETCH_BYTES.NAME=Quantit\u00E9 maximale de donn\u00E9es \u00E0 retourner par partition (octets)
MAX_PARTITION_FETCH_BYTES.DESCRIPTION=Nombre maximal de donn\u00E9es par partition retourn\u00E9 par le serveur. Le total maximal de m\u00E9moire utilis\u00E9e pour une requ\u00EAte est #partitions max.partition.fetch.bytes. \nCe total doit \u00EAtre au moins aussi grand que la taille maximale des messages autoris\u00E9e par le serveur, sinon le producteur risque d'envoyer des messages d\u00E9passant la limite des messages r\u00E9cup\u00E9rables par le consommateur. \n Si cela se produit, le consommateur se bloque en tentant de r\u00E9cup\u00E9rer un message volumineux dans une partition donn\u00E9e.
SESSION_TIMEOUT_MS.NAME=D\u00E9lai d'expiration de la session (en ms)
SESSION_TIMEOUT_MS.DESCRIPTION=D\u00E9lai avant expiration utilis\u00E9 pour d\u00E9tecter les \u00E9checs lors de l'utilisation des fonctionnalit\u00E9s de gestion de groupes de Kafka.=D\u00E9lai avant expiration de la session (ms)
PARTITION_ASSIGNOR.NAME=Attribution de partitions
PARTITION_ASSIGNOR.DESCRIPTION=Nom de la classe de la strat\u00E9gie d'attribution de partitions que le client utilise pour distribuer la propri\u00E9t\u00E9 des partitions parmi les instances consommatrices, lorsque la gestion de groupes est utilis\u00E9e.
CONSUMER_REQUEST_TIMEOUT_MS.NAME=Requ\u00EAte suspendue (en ms)
CONSUMER_REQUEST_TIMEOUT_MS.DESCRIPTION=La configuration contr\u00F4le l'intervalle maximal de temps durant lequel le client attend la r\u00E9ponse d'une requ\u00EAte. \nSi la r\u00E9ponse n'est pas re\u00E7ue avant la fin du d\u00E9lai de suspension, le client devra renvoyer la requ\u00EAte si n\u00E9cessaire ou faire \u00E9chouer la requ\u00EAte si le nombre de tentatives est \u00E9puis\u00E9.
BUFFER_MEMORY_SIZE.NAME=Taille de la m\u00E9moire tampon
BUFFER_MEMORY_SIZE.DESCRIPTION=Octets totaux de m\u00E9moire que le producteur peut utiliser pour mettre en m\u00E9moire tampon les enregistrements attendant d'\u00EAtre envoy\u00E9s au serveur. \nSi les enregistrements sont envoy\u00E9s plus rapidement qu'ils ne peuvent \u00EAtre livr\u00E9s au serveur, le producteur bloque ou retourne une exception, en se basant sur la pr\u00E9f\u00E9rence sp\u00E9cifi\u00E9e par block.on.buffer.full. \nCe param\u00E8tre doit correspondre \u00E0 peu pr\u00E8s \u00E0 la m\u00E9moire totale utilis\u00E9e par le producteur mais n'est pas une limite en dur, puisque toute la m\u00E9moire utilis\u00E9e par le producteur n'est pas utilis\u00E9e pour la mise en m\u00E9moire tampon. \nDe la m\u00E9moire suppl\u00E9mentaire sera utilis\u00E9e pour la compression (si la compression est activ\u00E9e), ainsi que pour maintenir les requ\u00EAtes \u00E0 la vol\u00E9e.
RETRIES.NAME=Nouvelles tentatives
RETRIES.DESCRIPTION=Configurer une valeur sup\u00E9rieure \u00E0 z\u00E9ro force le client \u00E0 renvoyer tout enregistrement dont l'envoi a \u00E9chou\u00E9, avec une erreur potentiellement transitoire. \nCette nouvelle tentative n'est pas diff\u00E9rente du renvoi d'un enregistrement par le client apr\u00E8s r\u00E9ception d'une erreur. \nLes requ\u00EAtes produites \u00E9chouent avant l'\u00E9puisement du nombre de nouvelles tentatives autoris\u00E9 si le d\u00E9lai avant expiration configur\u00E9 par delivery.timeout.ms expire avant le premier accus\u00E9 de r\u00E9ception envoy\u00E9 avec succ\u00E8s.\n Les utilisateurs pr\u00E9f\u00E8rent g\u00E9n\u00E9ralement laisser cette configuration non param\u00E9tr\u00E9e et utiliser \u00E0 la place la propri\u00E9t\u00E9 delivery.timeout.ms pour contr\u00F4ler le comportement des nouvelles tentatives. \nActiver l'idempotence n\u00E9cessite de configurer cette valeur \u00E0 'Sup\u00E9rieure \u00E0 0'. Si des configurations sont en conflit et que l'idempotence n'est pas explicitement activ\u00E9e, l'idempotence est d\u00E9sactiv\u00E9e. \nAutoriser les nouvelles tentatives tout en configurant enable.idempotence \u00E0 Faux et max.in.flight.requests.per.connection \u00E0 1 peut modifier l'ordre des enregistrements, car, si deux lots sont envoy\u00E9s dans une m\u00EAme partition, \nque le premier \u00E9choue et effectue une nouvelle tentative, et que le second r\u00E9ussit, les enregistrements du second lot peuvent appara\u00EEtre en premier.
PRODUCER_BATCH_SIZE.NAME=Taille des lots
PRODUCER_BATCH_SIZE.DESCRIPTION=Le producteur tente de grouper par lots des enregistrements en de moins nombreuses requ\u00EAtes lorsque de multiples enregistrements sont envoy\u00E9s \u00E0 la m\u00EAme partition. \nCela permet de meilleures performances du client et du serveur. Cette configuration contr\u00F4le, en octets, la taille des lots par d\u00E9faut. \nAucune tentative n'est effectu\u00E9e pour les lots d'enregistrements d\u00E9passant cette taille. Les requ\u00EAtes envoy\u00E9es aux brokers contiennent plusieurs lots, un pour chaque partition contenant des donn\u00E9es disponibles \u00E0 l'envoi. \nUne petite taille de lot permet d'avoir des lots moins fr\u00E9quents et peut r\u00E9duire le d\u00E9bit (une taille de lot configur\u00E9e \u00E0 z\u00E9ro d\u00E9sactive la mise en lots). \nUne tr\u00E8s grande taille de lot peut utiliser trop de m\u00E9moire, car la m\u00E9moire tampon est toujours allou\u00E9e en fonction de la taille du lot, pour anticiper d'\u00E9ventuels enregistrements suppl\u00E9mentaires.
CONNECTION_MAX_IDLE_MS.NAME=Max de connexions inactives (en ms)
CONNECTION_MAX_IDLE_MS.DESCRIPTION=Ferme les connexions inactives apr\u00E8s avoir attendu un nombre de millisecondes d\u00E9fini par cette configuration.
LINGER_MS.NAME=Attente (en ms)
LINGER_MS.DESCRIPTION=Le producteur regroupe les enregistrements arrivant entre les transmissions de requ\u00EAtes en une seule requ\u00EAte mise en lot.\nCela se produit normalement uniquement lorsque des enregistrements arrivent plus rapidement qu'ils ne peuvent \u00EAtre transf\u00E9r\u00E9s. Cependant, dans certaines circonstances, le client peut vouloir r\u00E9duire le nombre de requ\u00EAtes, m\u00EAme avec un chargement d'une taille mod\u00E9r\u00E9e.\n Ce param\u00E8tre le permet en ajoutant un petit d\u00E9lai artificiel. Plut\u00F4t que d'envoyer imm\u00E9diatement un enregistrement, le producteur attend jusqu'\u00E0 la fin du d\u00E9lai imparti, pour permettre l'envoi des autres enregistrements et regrouper les envois en un lot.\n Cela est assez similaire \u00E0 l'algorithme de Nagle pour le protocole TCP. Ce param\u00E8tre donne la limite haute du d\u00E9lai pour la mise en lots\u00A0: une fois une taille ad\u00E9quate d'enregistrements de batch.size atteinte pour une partition, les enregistrements sont imm\u00E9diatement envoy\u00E9s, quelle que soit la configuration de ce param\u00E8tre. Cependant, si la taille est inf\u00E9rieure, les octets accumul\u00E9s pour cette partition vont attendre l'heure sp\u00E9cifi\u00E9e, pour avoir davantage d'enregistrements \u00E0 envoyer.\n La valeur par d\u00E9faut de ce param\u00E8tre est de 0 (pas de d\u00E9lai). Configurer linger.ms=5, par exemple, permet de r\u00E9duire le nombre de requ\u00EAtes envoy\u00E9es, mais ajoute jusqu'\u00E0 5\u00A0ms de latence aux enregistrements envoy\u00E9s en l'absence de chargement.
MAX_BLOCK_MS.NAME=Nombre maximal de blocs (en ms)
MAX_BLOCK_MS.DESCRIPTION=La configuration contr\u00F4le la dur\u00E9e de blocage des m\u00E9thodes KafkaProducer\u2019s send(), partitionsFor(), initTransactions(), sendOffsetsToTransaction(), commitTransaction() et abortTransaction(). \nPour send(), ce d\u00E9lai avant expiration limite le temps d'attente total pour la r\u00E9cup\u00E9ration des m\u00E9tadonn\u00E9es et l'allocation de la m\u00E9moire tampon, (les blocages des s\u00E9rialiseurs ou des partitionneurs personnalis\u00E9s ne sont pas compt\u00E9s dans ce d\u00E9lai avant expiration). \nPour partitionsFor(), ce d\u00E9lai avant expiration limite le temps pass\u00E9 \u00E0 attendre les m\u00E9tadonn\u00E9es, si elles sont indisponibles. \nLes m\u00E9thodes relatives aux transactions bloquent toujours, mais peuvent expirer si la coordination des transactions ne peut \u00EAtre d\u00E9couverte ou r\u00E9pondre avant la fin du d\u00E9lai avant expiration.
MAX_REQUEST_SIZE.NAME=Taille maximale de la requ\u00EAte
MAX_REQUEST_SIZE.DESCRIPTION=Taille maximale d'une requ\u00EAte. Cette propri\u00E9t\u00E9 repr\u00E9sente \u00E9galement la taille maximale des enregistrements. \nNotez que le serveur a sa propre limite de taille des enregistrements, qui peut \u00EAtre diff\u00E9rente de celle-ci. \nCe param\u00E8tre limite le nombre de lots d'enregistrements que le producteur envoie en une seule requ\u00EAte, afin d'\u00E9viter l'envoi de requ\u00EAtes tr\u00E8s volumineuses.
RECEIVE_BUFFER_BYTES.NAME=Recevoir de la m\u00E9moire tampon (octets)
RECEIVE_BUFFER_BYTES.DESCRIPTION=Taille de la m\u00E9moire tampon de r\u00E9ception du protocole TCP (SO_RCVBUF) \u00E0 utiliser lors de la lecture des donn\u00E9es.
MAX_IN_FLIGHT_REQUEST.NAME=Requ\u00EAtes max sans accus\u00E9 de r\u00E9ception
MAX_IN_FLIGHT_REQUEST.DESCRIPTION=Nombre maximal de requ\u00EAtes sans accus\u00E9 de r\u00E9ception que le client va envoyer en une seule connexion avant de bloquer. \nNotez que, si la valeur de ce param\u00E8tre est sup\u00E9rieure \u00E0\u00A01 et que des envois \u00E9chouent, les messages risquent d'\u00EAtre r\u00E9ordonn\u00E9s, \u00E0 cause des nouvelles tentatives, si elles sont autoris\u00E9es.
METADATA_MAX_AGE_MS.NAME=Actualisation des m\u00E9tadonn\u00E9es max (en ms)
METADATA_MAX_AGE_MS.DESCRIPTION=P\u00E9riode de temps, en millisecondes, apr\u00E8s laquelle une actualisation forc\u00E9e des m\u00E9tadonn\u00E9es est effectu\u00E9e, m\u00EAme si aucune modification du leadership des partitions n'a \u00E9t\u00E9 effectu\u00E9e pour d\u00E9couvrir proactivement de nouveaux brokers ou de nouvelles partitions.
RECONNECT_BACKOFF_MS.NAME=Reconnecter le backoff (ms)
RECONNECT_BACKOFF_MS.DESCRIPTION=Temps d'attente avant une nouvelle tentative de reconnexion \u00E0 un h\u00F4te donn\u00E9. Cela \u00E9vite les reconnexions r\u00E9p\u00E9t\u00E9es \u00E0 un h\u00F4te dans une boucle. \nCe backoff s'applique \u00E0 toutes les requ\u00EAtes envoy\u00E9es au broker par le consommateur.
URI_OPTIONS.DESCRIPTION=Propri\u00E9t\u00E9s Kafka
USE_SCHEMA_REGISTRY.NAME=Utiliser le registre du sch\u00E9ma
SCHEMA_REGISTRY_URL.NAME=URL du registre du sch\u00E9ma
SCHEMA_REGISTRY_URL.DESCRIPTION=URL des serveurs de registre de sch\u00E9ma de Confluent Platform \u00E0 utiliser. Le format est\u00A0: host1:port1,host2:port2. \nCette URL est mentionn\u00E9e comme schema.registry.url dans la documentation de Confluent Platform. \nCette option est disponible uniquement dans Confluent Platform (Apache Kafka non standard).
